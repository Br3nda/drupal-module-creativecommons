<?php
// $Id: creativecommons.module,v 1.9.2.47 2009/08/12 00:20:22 balleyne Exp $

/**
 * @file
 * Creative Commons Drupal module
 *   Allows content within a site or attached to a node to
 *   be assigned a Creative Commons license.
 *   http://creativecommons.org/license/
 *
 *
 * By: Peter Bull <pbull@ltc.org>
 * 2005-02-28 / digitalbicycle.org / ltc.org
 * This software is released under the terms of the LGPL license, relicensed
 * under GPLv2 for drupal.org.
 *
 * Utilizes code and inspiration from http://cclicense.sourceforge.net/
 *   Originally released by Blake Watters <sbw@ibiblio.org>
 *   under the terms of the LGPL license (now, GPLv2 for drupal.org).
 *
 */

//TODO: split into relevant files
//TODO: review cc->new
//TODO: review link output to ensure l() used when necessary http://api.drupal.org/api/function/l/6

define('CC_API_ROOT', 'http://api.creativecommons.org/rest/1.5');

require_once('creativecommons.class.php');


/**
 * Enclose each arg in paragraph tags.
 */
//TODO: is there a drupal function that can replace this? or can this be deprecated?
function cc_para() {
  $args = func_get_args();
  $p = '';
  foreach ($args as $c)
    $p .= "<p>$c</p>";
  return $p;
}


/**
 * Implementation of hook_perm().
 */
function creativecommons_perm() {
  return array('administer creative commons', 'attach creative commons');
}


/**
 * Implementation of hook_menu().
 */
function creativecommons_menu() {
  $items = array();

  $items['admin/settings/creativecommons'] = array(
    'title' => 'Creative Commons',
    'description' => 'Configure the Creative Commons settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' =>  array('creativecommons_settings'),
    'access arguments' => array('administer creative commons')
  );

  $items['admin/settings/creativecommons/edit'] = array(
    'title' => 'settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10
  );

  $items['admin/settings/creativecommons/default'] = array(
    'title' => 'site defaults',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('creativecommons_site_defaults'),
    'access arguments' => array('administer creative commons'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/settings/creativecommons/types'] = array(
    'title' => 'content types',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('creativecommons_types_form'),
    'access arguments' => array('administer creative commons'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10
  );

  return $items;
}


/**
 * Implementation of hook_help().
 */
function creativecommons_help($path, $arg) {
  $cc_desc = 'A Creative Commons license helps you publish your work online while letting others know exactly what they can and can\'t do with your work. Creative Commons offers a flexible range of protections and freedoms for authors and artists, built upon the "all rights reserved" concept of traditional copyright to create a voluntary "some rights reserved" copyright.';
  $cc_desc_short = 'Assign a Creative Commons license to content that appears on the site.';
  $cc_node = 'Attaching a Creative Commons license to a node within Drupal can designate the content of that node, as well as any attached files, as available under that license.';

  //TODO: use l()
  $cc_url = 'For more information, visit <a href="http://creativecommons.org/learnmore">http://creativecommons.org/learnmore</a>.';

  switch ($path) {
    case 'admin/modules#description':
      return t($cc_desc_short);
    case 'admin/settings/creativecommons':
      return t(cc_para($cc_desc, $cc_node, $cc_url));
    case 'admin/help#creativecommons':
      return t(cc_para($cc_desc, $cc_node, $cc_url));
  }
}

/**
 * General Creative Commons settings page.
 */
function creativecommons_settings() {
  $available_license_types = creativecommons_get_available_license_types();
  $license_array_keys = creativecommons_get_licenses(array('jurisdiction' => variable_get('creativecommons_default_jurisdiction', '')), TRUE);
  $metadata_types_keys = creativecommons_get_metadata_types();

  $form['#submit'][] = 'creativecommons_settings_check_license_types_in_use';
  $form['creativecommons_license'] = array(
    '#type' => 'fieldset',
    '#title' => t('License selection'),
  );

  $form['creativecommons_license']['creativecommons_available_license_types'] = array(
    '#type' => 'select',
    '#title' => t('Available license types'),
    '#default_value' => $available_license_types,
    '#options' => $license_array_keys,
    '#description' => t('Select the license types to make available to users. (Hold CTRL to select multiple.)'),
    '#multiple' => TRUE,
    '#required' => TRUE,
  );

  $form['creativecommons_license']['creativecommons_required_metadata'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Required metadata fields'),
    '#default_value' => variable_get('creativecommons_required_metadata', array()),
    '#options' => $metadata_types_keys,
    '#description' => t('This option allows you to require specific metadata to be included when a license is applied.'),
  );

  //-------------------

  $form['creativecommons_display'] = array(
    '#type' => 'fieldset',
    '#title' => t('Node display'),
  );

  //TODO: add license name option (full_text, generic_text, short_text)

  // Load default site license for image samples (or CC BY 3.0 US if no default set)
  $default_license_uri = creativecommons_get_default_license_uri();
  $cc = new creativecommons_license($default_license_uri ? $default_license_uri : 'http://creativecommons.org/licenses/by/3.0/us/');

  $image_style_keys = array('button_large', 'button_small', 'icons');
  foreach ($image_style_keys as $style) {
    $image_styles[$style] = $cc->get_image($style) .' '. ucwords(str_replace('_', ' ', $style));
  }
  $image_styles[''] = t('(None)');

  $form['creativecommons_display']['creativecommons_image_style'] = array(
    '#type' => 'radios',
    '#title' => t('License image style'),
    '#options' => $image_styles,
    '#default_value' => variable_get('creativecommons_image_style', 'button_large'),
  );

  /* $form['creativecommons_display']['creativecommons_display'] = array(
    '#type' => 'radios',
    '#title' => t('Display license information'),
    '#default_value' => variable_get('creativecommons_display', 1),
    '#options' => array(
      t('Display text'),
      t('Display text and Creative Commons logo'),
      t('Display text and icons'),
      t('Do not display license')
    ),
    '#description' => t('You can display license details when viewing a node.'),
    '#required' => TRUE,
    '#attributes' => FALSE,
  );*/

  // TODO: 2.x revisit (and probably remove) this when ccREL is implemented, since RDF/XML is no longer recommended
  $form['creativecommons_display']['creativecommons_rdf'] = array(
    '#type' => 'checkbox',
    '#title' => t('Insert RDF/XML'),
    '#return_value' => 1,
    '#default_value' => variable_get('creativecommons_rdf', TRUE),
    '#description' => t('Attach machine-readable license information as RDF/XML within the HTML of a node to let visitors know what license applies to your works.'),
  );
  return system_settings_form($form);

}

function creativecommons_settings_check_license_types_in_use($form, &$form_state) {
  $prev = creativecommons_get_available_license_types();
  $curr = $form_state['values']['creativecommons_available_license_types'];
  foreach ($prev as $type) {
    if (!in_array($type, $curr)) {
      $count = creativecommons_count_by_license_type($type);
      if ($count > 0) {
        $name = creativecommons_get_license_type_name($type);
        $message = "There ". ($count > 1 ? 'are' : 'is') ." $count node". ($count > 1 ? 's' : '') ." currently using the $name license. Licensing information will be hidden when viewing these nodes until adjusted.";
        drupal_set_message($message, 'warning', FALSE);
      }
    }
  }
}

/**
 * Checks to see if any license types are available. If not, sets a warning.
 */
function creativecommons_licenses_enabled() {
  $available_license_types = creativecommons_get_available_license_types();

  // Need to use count, because special case where only None is available (e.g. 'Array( [] => )')
  if (count($available_license_types) == 0) {
    drupal_set_message('Creative Commons: no license types are enabled!', 'warning', FALSE);
  }
}

/**
 * Creative Commons site license settings form
 */
function creativecommons_site_defaults() {
  creativecommons_licenses_enabled();

  // Load default license
  $cc = creativecommons_get_default_license();

  // Check to see if default license is still available
  if ($cc->has_license() && !$cc->is_available()) {
    $message = $cc->get_name();
    $message .= $cc->is_valid() ? ' is no longer available' : ' is not valid';
    drupal_set_message($message, 'warning');
  }

  $node->cc = $cc; //TODO: necessary?

  $form['creativecommons_default_license'] = array(
    '#type' => 'fieldset',
    '#title' => t('Default license'),
  );

  $available_license_types = creativecommons_get_available_license_list(NULL, TRUE);

  // If None isn't an option, create blank first entry
  if (!in_array('', $available_license_types)) {
    $available_license_types = array_merge( array('' => ''), $available_license_types );
  }

  $form['creativecommons_default_license']['creativecommons_default_license_type'] = array(
    '#type' => 'select',
    '#title' => t('License type'),
    '#default_value' => variable_get('creativecommons_default_license_type', ''),
    '#options' => $available_license_types,
    '#description' => t('Select the site wide default license type for new content.'),
  );

  $q = creativecommons_get_questions_array('standard');
  $form['creativecommons_default_license']['creativecommons_default_jurisdiction'] = array(
    '#type' => 'select',
    '#title' => t('Default jurisdiction'),
    '#description' => t($q['jurisdiction']['description']),
    '#options' => creativecommons_format_jurisdiction_array($q['jurisdiction']['answers']),
    '#default_value' => variable_get('creativecommons_default_jurisdiction', ''),
  );


  // site license display
  $form['creativecommons_site_license'] = array(
    '#type' => 'fieldset',
    '#title' => t('Site license'),
  );
  $form['creativecommons_site_license']['creativecommons_site_license_display'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use default license as site wide license to be displayed on every page?'),
    '#return_value' => 1,
    '#default_value' => variable_get('creativecommons_site_license_display', FALSE),
  );


  // Site license metadata
  $site_metadata = variable_get('creativecommons_site_metadata', array());

  $hasmeta = FALSE;
  foreach ($site_metadata as $key => $value) {
    if ($value) {
      $hasmeta = TRUE;
    }
  }

  $form['creativecommons_site_license']['metadata'] = array(
    '#type' => 'fieldset',
    '#title' => 'Additional Information',
    '#description' => 'If default license is used as site wide license, the following metadata will apply.',
    '#collapsible' => TRUE,
    // show additional info by default if (a) site-license enabled and (b) some metadata fields non-empty; otherwise, hide.
    '#collapsed' => !($hasmeta && variable_get('creativecommons_site_license_display', FALSE)),
    '#tree' => TRUE,
    );

  // Default site wide metadata values
  /* TODO: 2.x this should be done on output, otherwise creates redundancy. What if
  site title changes?
  $defaults = array('type' => 'InteractiveResource',
                    'attributionURL' => url('<front>', array('absolute' => TRUE)),
                    'title' => variable_get('site_name', ''),
                    'description' => variable_get('site_mission', ''),
              ); */
  $defaults = array();

  $metadata_types = creativecommons_get_metadata_types();

  // build metadata form fields TODO: code is very similar to node form -- refactor?
  foreach ($metadata_types as $key => $title) {
    $title = 'Website '. $title;

    switch ($key) {
      case 'type':
        $form['creativecommons_site_license']['metadata'][$key] = array(
          '#type' => 'select',
          '#title' => t($title),
          '#default_value' => array_key_exists($key, $site_metadata) ? $site_metadata[$key] : $defaults[$key],
          '#options' => creativecommons_get_dcmi_types(),
          '#description' => creativecommons_get_metadata_description($key),
          '#extra' => NULL,
          '#multiple' => NULL,
        );
        break;

      case 'description':
        $form['creativecommons_site_license']['metadata'][$key] = array(
          '#type' => 'textarea',
          '#title' => t($title),
          '#default_value' => array_key_exists($key, $site_metadata) ? $site_metadata[$key] : $defaults[$key],
          '#cols' => 60,
          '#rows' => 5,
          '#description' => creativecommons_get_metadata_description($key),
          '#attributes' => NULL,
        );
        break;

      default:
        $form['creativecommons_site_license']['metadata'][$key] = array(
          '#type' => 'textfield',
          '#title' => t($title),
          '#default_value' => array_key_exists($key, $site_metadata) ? $site_metadata[$key] : $defaults[$key],
          '#size' => 50,
          '#maxlength' => 255,
          '#description' => creativecommons_get_metadata_description($key),
          '#attributes' => NULL,
        );
        break;
    }
  }

  $form['creativecommons_site_license']['creativecommons_site_license_additional_text'] = array(
    '#type' => 'textarea',
    '#title' => t('Additional text'),
    '#default_value' => variable_get('creativecommons_site_license_additional_text', NULL),
    '#cols' => 60,
    '#rows' => 3,
    '#description' => t('This text will accompany the display of the site license.'),
    '#attributes' => NULL,
    '#required' => NULL,
  );

  $form['#submit'][] = 'creativecommons_site_defaults_submit';
  return system_settings_form($form);
}

/**
 * Submit function for site_defaults form. Stores metadata as array.
 */
function creativecommons_site_defaults_submit($form, &$form_state) {
  if ($form_state['values']['metadata']) {
    variable_set('creativecommons_site_metadata', $form_state['values']['metadata']);
    unset($form_state['values']['metadata']);
  }
}

/**
 * Form builder. Allow administrator to enable Creative Commons licensing for
 * content types in one central location.
 */
function creativecommons_types_form() {
  creativecommons_licenses_enabled();

  $form = array();

  $form['creativecommons_license']['creativecommons_node_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Content Types'),
    '#default_value' => variable_get('creativecommons_node_types', array()),
    '#options' => node_get_types('names'),
    '#description' => t('Enable Creative Commons licensing for the following content types.'),
  );

  return system_settings_form($form);
}


/**
 * Display license selection form
 *
 * @param $simple - use simple chooser if true
 */
function creativecommons_select_license_form($node, $key, $form_state_segment = NULL) {
  // load available licenses
  $default_jurisdiction = variable_get('creativecommons_default_jurisdiction', '');
  $available_licenses = creativecommons_get_available_license_list( array('jurisdiction' => $default_jurisdiction) );
  $available_license_types = creativecommons_get_available_license_types();
  $jurisdictions = creativecommons_get_jurisdictions();


  /**
   * Determine which license to select from the list.
   *
   * Three cases (in order):
   *  1. license uri already selected in form (i.e. preview)
   *  2. license uri is already attached to the node
   *  3. No license information selected or attached, so fall back to defaults.
   */

  // Case 1: If license uri selected in form, use that
  if ($form_state_segment && isset($form_state_segment[$key])) {
    $desired_license = new creativecommons_license($form_state_segment[$key]);
  }
  // Case 2: Otherwise, use license uri attached to node
  elseif ($node->cc) {
    $desired_license = new creativecommons_license($node->cc->uri);
  }
  // Case 3: Otherwise, use default uri
  else {
    $desired_license = creativecommons_get_default_license();
  }



  /**
   * Check the desired URI against the list.
   *
   * There are three (known) cases (in order) where the desired uri won't be in
   * the list:
   *  1. the license type is no longer available;
   *  2. the default jurisdiction has changed;
   *  3. a new version of the license has been released.
   */
  $selected_license_uri = creativecommons_get_license_uri_from_available($desired_license->type, $default_jurisdiction);

  // Warn user if changed (if selected doesn't match desired, or (special case) if node->cc is None but that's not available)
  if (($desired_license->uri != $selected_license_uri) || ($node->cc && !$desired_license->uri && !$desired_license->is_available())) {
    $selected_license = new creativecommons_license($selected_license_uri);

    // Case 1: License is no longer available
    if (!$desired_license->is_available()) {
      $message = '"'. $desired_license->get_name() .'" is no longer an option. Please review license selection.';
    }
    // Case 2: Jurisdiction change (same license type)
    elseif ($desired_license->jurisdiction != $selected_license->jurisdiction) {
      $message = 'The jurisdiction of your license will be changed from '. $jurisdictions[$desired_license->jurisdiction] .' to '. $jurisdictions[$selected_license->jurisdiction] .'. Please review.';
    }
    // Case 3: Version change (upgrade)
    elseif ($desired_license->version != $selected_license->version) {
      $message = 'The version of your license will be changed from '. $desired_license->version .' to '. $selected_license->version .'. Please review.';
    }
    // Any other cases?
    else {
      $message = 'Your license selection is set to be altered. Please review.';
    }
    drupal_set_message($message, 'warning');
  }



  /**
    * If selected_license_uri is blank but None is not an available type,
    * then a blank entry is placed at the beginning of the list (and the field
    * is set to required). This forces the user to actively select a license,
    * rather than just defaulting to the first on the list.
    *
    * This will only arise in the following cases:
    *  - if content had no license (None), but that is no longer an available type
    *  - if there is no site default set, but None is not an available type
    */
  if (!$selected_license_uri && !in_array('', $available_license_types)) {
    $available_licenses = array_merge( array('' => ''), $available_licenses);
  }



  /**
   * (After all this hard work,) the form element.
   */
  $form[$key] = array(
    '#type' => 'select',
    '#title' => t('Creative Commons License'),
    '#default_value' => $selected_license_uri,
    '#options' => $available_licenses,
    '#attributes' => $extra,
    '#description' => NULL,
    '#required' => !in_array('', $available_license_types) ? TRUE : FALSE,
  );


  return $form;
}

/**
 * Provides license uri validation for form validate methods to use.
 */
function creativecommons_validate_license_uri($license_uri_key, $license_uri) {
  // Check to see if selected license is available
  $cc = new creativecommons_license($license_uri);
  if ($cc->has_license() && !$cc->is_available()) {
    $message = $cc->get_name();
    $message .= $cc->is_valid() ? ' is no longer available.' : ' is not a valid license.';

    form_set_error($license_uri_key, $message);
  }
}



/**
 * Return default license. 'Empty' license returned if no default set.
 */
function creativecommons_get_default_license() {
  $license_uri = creativecommons_get_default_license_uri();
  return new creativecommons_license($license_uri);
}

/**
 * Return site license, including metadata.
 */
function creativecommons_get_site_license() {
  $license_uri = creativecommons_get_default_license_uri();
  return new creativecommons_license($license_uri, NULL, variable_get('creativecommons_site_metadata', array()));
}
/**
 * Return default license URI.
 */
function creativecommons_get_default_license_uri() {
  $default_license_type = variable_get('creativecommons_default_license_type', '');
  $default_jurisdiction = variable_get('creativecommons_default_jurisdiction', '');

  return creativecommons_get_license_uri_from_available($default_license_type, $default_jurisdiction);
}

/**
 * Parse license URI and return type.
 * @param $uri - a valid CC license uri
 * @return license type (e.g. 'by-sa')
 */
function creativecommons_get_license_type_from_uri($uri) {
  $parts = explode('/', $uri);

  return $parts[4];
}


/**
 * Strip out jurisdiction and version from license name.
 *
 * @param $name - full name of a CC license
 * @return license name, without version number or jurisdiction
 */
function creativecommons_generic_license_name($full_name) {
  $name_parts = explode(' ', $full_name);
  $version_part = count($name_parts);

  // Find the version number (only numeric part)
  $i = 0;
  foreach ($name_parts as $part) {
    if (is_numeric($part))
      $version_part = $i;
    $i++;
  }

  // Build the name, up to but not including version number
  $name = $name_parts[0];
  for ($i=1;$i<$version_part;$i++)
    $name .= ' '. $name_parts[$i] ;

  return $name;
}

/**
 * Return list of jurisdictions from CC API.
 */
function creativecommons_get_jurisdictions() {
  $uri = '/support/jurisdictions';
  $xml = '<jurisdictions>'. creativecommons_return_xml($uri) .'</jurisdictions>';

  $parser = xml_parser_create();
  xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
  xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);
  xml_parse_into_struct($parser, $xml, $values, $index);
  xml_parser_free($parser);

  $jurisdictions = array('' => 'Generic');
  foreach ($values as $key) {
    if ($key['tag'] == 'option' && $key['level'] == 2) {
      $id = explode('/', $key['attributes']['value']);
      $jurisdictions[$id[4]] = $key['value'];
    }
  }

  return $jurisdictions;
}

/**
 * Take the raw array of jurisdictions from the CC API and format it for use in
 * a Drupal form by flipping keys/values, and sorting by Jurisdiction name
 * @param $raw_array - array of jurisdictions from CC API
 * @return array of jurisdictions for use in Drupal form
 */
function creativecommons_format_jurisdiction_array($raw_array) {
  $jurisdictions = array();

  foreach ($raw_array as $name => $id)
    $jurisdictions[$id] = $name;

  // Sort by Jurisdiction name
  asort($jurisdictions);

  // Move special case 'Generic' to front
  $generic = array('' => $jurisdictions['']);
  unset($jurisdictions['']);
  $jurisdictions = array_merge($generic, $jurisdictions);

  return $jurisdictions;
}


/**
 * Return array of all available licenses, grouped by class, for use in a Drupal
 * form.
 *
 * @param $options - optional array of options for CC API simple license
 * chooser, as per: http://api.creativecommons.org/docs/readme_15.html#simple-chooser
 * @param $value_as_type - if set to TRUE, the key for each license will be the
 *                        license type (e.g. 'by-sa'), instead of the full URI.
 * @return array of all available license
 */
function creativecommons_get_licenses($options = NULL, $value_as_type = FALSE) {
  $licenses = array();

  // Unlicensed
  $blank_license = new creativecommons_license('');
  $licenses[''] = $blank_license->get_name();

  // License classes
  $licenses['Creative Commons'] = array();
  $licenses['Public Domain'] = array();

  // Manual adjustments for 'standard' class
  $parser = xml_parser_create();
  xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
  xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);

  $uri = '/simple/chooser';
  if ($options)
    $uri .= '?'. http_build_query($options);
  $standard_xml = '<standard>'. creativecommons_return_xml($uri) .'</standard>';

  xml_parse_into_struct($parser, $standard_xml, $standard_licenses, $index);
  xml_parser_free($parser);

  foreach ($standard_licenses as $key) {
    if ($key['tag'] == 'option' && $key['level'] == 2) {
      // strip out license type identifier from uri
      $license_uri = $key['attributes']['value'];
      $license_type = creativecommons_get_license_type_from_uri($license_uri);

      $license_key = $value_as_type ? $license_type : $license_uri;
      $license_name = $value_as_type ? creativecommons_generic_license_name($key['value']) : $key['value'];

      $license_class = $license_type == 'publicdomain' ? 'Public Domain' : 'Creative Commons';
      $licenses[$license_class][$license_key] = $license_name;
    }
  }

  // CC0
  $zero = new creativecommons_license('http://creativecommons.org/publicdomain/zero/1.0/');

  if ($value_as_type)
    $licenses['Public Domain'][$zero->type] = creativecommons_generic_license_name($zero->get_name());
  else
    $licenses['Public Domain'][$zero->uri] = $zero->get_name();

  return $licenses;
}


/**
 * Return an array of available license types.
 */
function creativecommons_get_available_license_types() {
  return variable_get('creativecommons_available_license_types', array());
}

/**
 * Return name of license
 * @param $type
 */
function creativecommons_get_license_type_name($type) {
  $license_array = creativecommons_get_licenses(NULL, TRUE);
  foreach ($license_array as $licenses) {
    if (is_array($licenses) && array_key_exists($type, $licenses)) {
      return $licenses[$type];
    }
  }
}

/**
 * Return an array of available licenses.
 * @param $options -- options for querying the CC API for available licenses
 * @param $first_entry_blank -- if TRUE, insert blank entry at start of array
 *
 * @return array of available licenses
 */
function creativecommons_get_available_license_list($options = NULL, $value_as_type = FALSE) {
  $licenses = creativecommons_get_licenses($options, $value_as_type);

  $available_licenses = creativecommons_remove_unavailable_licenses($licenses);

  // Clear out empty license classes (e.g. Don't show Public Domain optgroup if PD and CC0 not enabled)
  foreach ($available_licenses as $class => $value) {
    if (empty($value)) {
      unset($available_licenses[$class]);
    }
  }

  return $available_licenses;
}

/**
 * Takes a list of licenses and unsets any which are not available in the site settings.
 * @param $list  list of licenses to check
 */
function creativecommons_remove_unavailable_licenses($list, $available_license_types = NULL) {

  if (!$available_license_types)
    $available_license_types = creativecommons_get_available_license_types();

  foreach ($list as $key => $value) {
    if (is_array($value)) {
      $list[$key] = creativecommons_remove_unavailable_licenses(&$value, $available_license_types);
    }
    elseif (!in_array($key, $available_license_types) && !in_array(creativecommons_get_license_type_from_uri($key), $available_license_types))
      unset($list[$key]);
  }

  return $list;
}

/**
 * Return true if license uri receives a valid response from CC API, false
 * otherwise.
 */
function creativecommons_is_available_license_uri($license_uri) {
  $cc = new creativecommons_license($license_uri);
  return $cc->is_available();
}

/**
 * Lookup license uri based on type and jurisdiction (only searches available types)
 * @param $license_type (e.g. by, by-sa)
 * @param $jurisdiction (e.g. us, ca)
 * @return valid license-uri, or empty string if none found
 */
function creativecommons_get_license_uri_from_available($license_type, $jurisdiction) {
  if (!$license_type) {
    return '';
  }

  // TODO: option to search all licenses? instead of just available?
  $available_licenses = creativecommons_get_available_license_list( array('jurisdiction' => $jurisdiction) );

  foreach ($available_licenses as $class => $licenses) {
    if (is_array($licenses)) {
      foreach ($licenses as $uri => $title) {
        if ($license_type == creativecommons_get_license_type_from_uri($uri)) {
          $license_uri = $uri;
        }
      }
    }
  }

  return $license_uri;
}

/**
 * Send HTTP Request to CC API services.
 * $uri     relative uri of file content on CC api site, not inclucing interface root (can be '')
 * $headers An array containing an HTTP header => value pair.
 * $method  A string defining the HTTP request to use.
 * $data    A string containing data to include in the request.
 */
function creativecommons_api_request($uri, $headers = array(), $method = 'GET', $data = NULL) {

  $uri = CC_API_ROOT . (strpos($uri, '/') === 0 ? $uri : '/'. $uri);

  $result = drupal_http_request($uri, $headers, $method, $data);

  if ($result->error)
    drupal_set_message('Error accessing CC API: '. $result->error, 'error', FALSE);

  return $result;
}

/**
 * Refreshes cached XML if file is greater than $hrs hours old
 * $filename	name up file to be retrieved/updated
 * $uri		uri of file content on CC api site, beyond the interface root (if any)
 * $hrs		file should be updated if older then X number of hours
 * $update	force update of the file
 */
function creativecommons_return_xml($uri, $hrs = 24, $update = FALSE) {
  // check for xml variable
  $xml = variable_get('creativecommons_api_'. $uri, NULL);
  if ($xml) {

    // get timestamp ***directly from variables table*** to avoid caching
    $result = db_query("SELECT value FROM {variable} WHERE name = '%s'", 'creativecommons_api_'. $uri .'_timestamp');
    if ($row = db_fetch_object($result)) {
      if ($ts = unserialize($row->value)) {
        $diff = (time() - $ts)/60/60;
        if ($diff >= $hrs)
          $update = TRUE;
      }
      else $update = TRUE;
    }
    else $update = TRUE;
  }
  else $update = TRUE;

  // request xml
  if ($update) {
    $headers = array();
    $result = creativecommons_api_request($uri, $headers);
    switch ($result->code) {
      case 200:
        variable_set('creativecommons_api_'. $uri, $result->data);
        variable_set('creativecommons_api_'. $uri .'_timestamp', time());
        return $result->data;
        break;
      default:
        return;
        break;
    }
  }
  else return $xml;
}

/**
 * Return associative array of metadata names.
 */
//TODO: 2.x add ns to key (e.g. cc:attributionName)
function creativecommons_get_metadata_types() {
  return array(
    // from http://creativecommons.org/ns
    'attributionName' => t('Attribution Name'),
    'attributionURL' => t('Attribution URL'),
    'morePermissions' => l('CC+', 'http://wiki.creativecommons.org/CCPlus') .' '. t('URL'),

    // from http://dublincore.org/documents/dces/
    'title' => t('Title'),
    'type' => t('Type'),
    'description' => t('Description'),
    'creator' => t('Creator'),
    'rights' => t('Copyright holder'),
    'date' => t('Year of copyright'),
    'source' => t('Source work URL'),
  );
}

/**
 * Return a description of the metadata type.
 */
//TODO: 2.x add ns to key (e.g. cc:attributionName)
function creativecommons_get_metadata_description($key) {
  $descriptions = array(
    // from http://creativecommons.org/ns
    'attributionName' => t('The name the creator of a Work would like used when attributing re-use'),
    'attributionURL' => t('The URL the creator of a Work would like used when attributing re-use'),
    'morePermissions' => t('The URL where additional permissions or alternative licenses for a Work are available'),

    // from http://dublincore.org/documents/dces/
    'title' => t('A name by which the Work is formally known'),
    'type' => t('The nature or genre of the Work'),
    'description' => t('An account of the Work'),
    'creator' => t('An entity primarily responsible for making the Work'),
    'rights' => t('Information about rights held in and over the Work'),
    'date' => t('Year of copyright'),
    'source' => t('A related resource from which the described Work is derived'),
  );

  $links = array(
    'attributionName' => l('cc:attributionName', 'http://creativecommons.org/ns#attributionName'),
    'attributionURL' => l('cc:attributionURL', 'http://creativecommons.org/ns#attributionURL'),
    'morePermissions' => l('cc:morePermissions', 'http://creativecommons.org/ns#morePermissions'),

    'title' => l('dc:title', 'http://dublincore.org/documents/dces/#title'),
    'type' => l('dc:type', 'http://dublincore.org/documents/dces/#type'),
    'description' => l('dc:description', 'http://dublincore.org/documents/dces/#description'),
    'creator' => l('dc:creator', 'http://dublincore.org/documents/dces/#creator'),
    'rights' => l('dc:rights', 'http://dublincore.org/documents/dces/#rights'),
    'date' => l('dc:date', 'http://dublincore.org/documents/dces/#date'),
    'source' => l('dc:source', 'http://dublincore.org/documents/dces/#source'),
  );
  return $descriptions[$key] .' (see '. $links[$key] .').';
}

/**
 * Return array of questions for specified license
 */
function creativecommons_get_questions_array($license_id) {
  $question_xml = creativecommons_get_questions_xml($license_id);
  $parser = xml_parser_create();
  xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
  xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);
  xml_parse_into_struct($parser, $question_xml, $values, $index);
  xml_parser_free($parser);

  $questions = array();
  foreach ($values as $xn) {

    // new question array item
    if ($xn['tag'] == 'field' && $xn['type'] == 'open') {
      $current = $xn['attributes']['id'];
      $questions[$current] = array();
    }

    // set description
    if ($xn['tag'] == 'description')
      $questions[$current]['description'] = $xn['value'];

    // set question
    if ($xn['tag'] == 'label' && is_null($questions[$current]['answers'])
      && $current !== NULL && is_null($ans_lbl)) {
      $questions[$current]['question'] = $xn['value'];
    }

    // set answer labels/values
    if ($ans_lbl !== NULL && $ans_val !== NULL) {
      $questions[$current]['answers'][$ans_val] = $ans_lbl;
      $ans_lbl = NULL;
      $ans_val = NULL;
    }
    if ($xn['tag'] == 'enum' && $xn['type'] == 'open')
      $ans_lbl = $xn['attributes']['id'];
    if ($xn['tag'] == 'label' && $ans_lbl !== NULL)
      $ans_val = $xn['value'];
  }

  return $questions;
}

/**
 * Return xml defining questions/answers for a specific creative commons license
 */
function creativecommons_get_questions_xml($license_id) {
  if ($license_id != 'none' && !is_null($license_id)) {
    $filename = $license_id .'.xml';
    return creativecommons_return_xml('/license/'. $license_id .'/');
  }
  return;
}

/**
 * Return array of DCMI types,
 * based on http://dublincore.org/documents/dcmi-type-vocabulary/
 */
function creativecommons_get_dcmi_types() {
  $dcmi_types = array(
    '' => '',
    'Collection' => 'Collection',
    'Dataset' => 'Dataset',
    'Event' => 'Event',
    'Image' => 'Image',
    'InteractiveResource' => 'Interactive Resource',
    'MovingImage' => 'Moving Image',
    //'PhysicalObject' => 'Physical Object',
    'Service' => 'Service',
    'Software' => 'Software',
    'Sound' => 'Sound',
    'StillImage' => 'Still Image',
    'Text' => 'Text',
    );
  return $dcmi_types;
}


/**
 * Implementation of hook_nodeapi().
 */
function creativecommons_nodeapi(&$node, $op, $arg, $a4) {

  switch ($op) {
    // settings   'form post replaced by form_api
    case 'load':
      if (creativecommons_node_type_is_enabled($node->type))
        $node->cc = new creativecommons_license('', $node->nid);
      break;

    case 'view':
      creativecommons_view($node, FALSE, FALSE, TRUE);
      break;

    case 'insert':
    case 'update':
      creativecommons_save($node, $op);
      break;

    case 'delete':
      creativecommons_delete($node);
      break;

    //TODO: review
    case 'rss item':
      if ($item_license = creativecommons_xml($node))
        return $item_license;
      break;
  }
  return $output;
}

/**
 * Implementation of hook_form_alter().
 */
function creativecommons_form_alter(&$form, $form_state, $form_id) {
  // Add content type checkbox to node_type_form
  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {
    $node->type = $form['#node_type']->type;
    $form['workflow']['creativecommons'] = array(
      '#type' => 'checkbox',
      '#title' => t('Allow user to attach a Creative Commons license'),
      '#description' => t('Users with the <em>attach creative commons</em> permission will be able to select a license for a work of this type.'),
      '#return_value' => 1,
      '#default_value' => creativecommons_node_type_is_enabled($node->type) ? 1 : 0,
    );
    $form['#submit'][] = 'creativecommons_node_type_submit';
  }
  // Add CC license selection to node form
  elseif (isset($form['type']) && $form['type']['#value'] .'_node_form' == $form_id) {
    $node = $form['#node'];
    if (creativecommons_node_type_is_enabled($node->type)) {
        $form = array_merge($form, creativecommons_node_form($form['#node'], $form_state));
    }
  }
  // Add search fields to Content search form
  //TODO: can these fields be added to node_search? (yes, but it's not obvious how that search would actually be done...)
  elseif ($form_id == 'search_form' && ($form['module']['#value'] == 'creativecommons') && user_access('use advanced search')) {
    //TODO: super hack, shouldn't be using $_GET
    $cc_search_filters = explode(',', search_query_extract(str_replace('search/creativecommons/', '', $_GET['q']), 'cc'));

    $form['creativecommons'] = array(
      '#type' => 'fieldset',
      '#title' => t('Creative Commons'),
      '#description' => t('Find content that can be...'),
      '#attributes' => array('class' => 'search-creativecommons'), //TODO: more of this elsewhere!
    );
    $form['creativecommons']['commercial_use'] = array(
      '#type' => 'checkbox',
      '#title' => t('used for <strong>commercial purposes</strong>'),
      '#default_value' => in_array('commercial_use', $cc_search_filters),
    );

    $form['creativecommons']['derivative_works'] = array(
      '#type' => 'checkbox',
      '#title' => t('<strong>modified</strong>, <strong>adapted</strong> or <strong>built upon</strong>'),
      '#default_value' => in_array('derivative_works', $cc_search_filters),
    );
    
    $form['#validate'][] = 'creativecommons_search_validate';
    
    /**
     * Advanced node search form (copied from node_form_alter()...). Ideally,
     * this code should not be copied, but the CC search filter should simply be
     * integrated into the node_search(). It's just not clear how to do that...
     */
    // Keyword boxes:
    $form['advanced'] = array(
      '#type' => 'fieldset',
      '#title' => t('Advanced search'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => array('class' => 'search-advanced'),
    );
    $form['advanced']['keywords'] = array(
      '#prefix' => '<div class="criterion">',
      '#suffix' => '</div>',
    );
    $form['advanced']['keywords']['or'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing any of the words'),
      '#size' => 30,
      '#maxlength' => 255,
    );
    $form['advanced']['keywords']['phrase'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing the phrase'),
      '#size' => 30,
      '#maxlength' => 255,
    );
    $form['advanced']['keywords']['negative'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing none of the words'),
      '#size' => 30,
      '#maxlength' => 255,
    );

    // Taxonomy box:
    if ($taxonomy = module_invoke('taxonomy', 'form_all', 1)) {
      $form['advanced']['category'] = array(
        '#type' => 'select',
        '#title' => t('Only in the category(s)'),
        '#prefix' => '<div class="criterion">',
        '#size' => 10,
        '#suffix' => '</div>',
        '#options' => $taxonomy,
        '#multiple' => TRUE,
      );
    }

    // Node types:
    $types = array_map('check_plain', node_get_types('names'));
    $form['advanced']['type'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Only of the type(s)'),
      '#prefix' => '<div class="criterion">',
      '#suffix' => '</div>',
      '#options' => $types,
    );
    $form['advanced']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Advanced search'),
      '#prefix' => '<div class="action">',
      '#suffix' => '</div>',
    );
    $form['#validate'][] = 'node_search_validate';
  }

  return $form;
}

/**
 * Implementation of hook_search().
 */
function creativecommons_search($op = 'search', $keys = NULL) {
  switch ($op) {
    case 'name':
      return t('Creative Commons'); //TODO: review translation bit
    case 'search':
      // Extract CC filters from query
      $cc_search_filters = explode(',', search_query_extract($keys, 'cc'));
      
      // Load available licenses
      $cc_licenses = array();
      foreach (creativecommons_get_available_license_list() as $class => $licenses) {
        foreach (array_keys($licenses) as $uri) {
          $cc_licenses[] = new creativecommons_license($uri);
        }
      }
    
      # Next for lines from node_search()
      // Build matching conditions
      list($join1, $where1) = _db_rewrite_sql();
      $arguments1 = array();
      $conditions1 = 'n.status = 1';
      # end node_search lines
      
      // Creative Commons search filters
      $keys = search_query_insert($keys, 'cc');
      $conditions1 .= " AND cc.license_uri LIKE 'http://creativecommons.org/%'"; // only return CC licensed content
      $join1 .= ' INNER JOIN {creativecommons} cc ON i.sid=cc.nid';
      
      foreach (array('commercial_use', 'derivative_works') as $filter) {
        if (in_array($filter, $cc_search_filters)) {
          $filter_function = 'permits_'. $filter;
          $cc_conditions = array();
          foreach ($cc_licenses as $license) {
            if ($license->$filter_function()) {
              $cc_conditions[] = "cc.license_uri LIKE 'http://creativecommons.org/%/". creativecommons_get_license_type_from_uri($license->uri) ."/%'";
            }
          }
          $conditions1 .= ' AND ('. implode(' OR ', $cc_conditions) .')';
        }
      }

      /**
       * The rest of the code for this case has been copied from node_search(),
       * with the exception of one line to add the CC license into the title text.
       */
      if ($type = search_query_extract($keys, 'type')) {
        $types = array();
        foreach (explode(',', $type) as $t) {
          $types[] = "n.type = '%s'";
          $arguments1[] = $t;
        }
        $conditions1 .= ' AND ('. implode(' OR ', $types) .')';
        $keys = search_query_insert($keys, 'type');
      }

      if ($category = search_query_extract($keys, 'category')) {
        $categories = array();
        foreach (explode(',', $category) as $c) {
          $categories[] = "tn.tid = %d";
          $arguments1[] = $c;
        }
        $conditions1 .= ' AND ('. implode(' OR ', $categories) .')';
        $join1 .= ' INNER JOIN {term_node} tn ON n.vid = tn.vid';
        $keys = search_query_insert($keys, 'category');
      }
      
      // Build ranking expression (we try to map each parameter to a
      // uniform distribution in the range 0..1).
      $ranking = array();
      $arguments2 = array();
      $join2 = '';
      // Used to avoid joining on node_comment_statistics twice
      $stats_join = FALSE;
      $total = 0;
      if ($weight = (int)variable_get('node_rank_relevance', 5)) {
        // Average relevance values hover around 0.15
        $ranking[] = '%d * i.relevance';
        $arguments2[] = $weight;
        $total += $weight;
      }
      if ($weight = (int)variable_get('node_rank_recent', 5)) {
        // Exponential decay with half-life of 6 months, starting at last indexed node
        $ranking[] = '%d * POW(2, (GREATEST(MAX(n.created), MAX(n.changed), MAX(c.last_comment_timestamp)) - %d) * 6.43e-8)';
        $arguments2[] = $weight;
        $arguments2[] = (int)variable_get('node_cron_last', 0);
        $join2 .= ' LEFT JOIN {node_comment_statistics} c ON c.nid = i.sid';
        $stats_join = TRUE;
        $total += $weight;
      }
      if (module_exists('comment') && $weight = (int)variable_get('node_rank_comments', 5)) {
        // Inverse law that maps the highest reply count on the site to 1 and 0 to 0.
        $scale = variable_get('node_cron_comments_scale', 0.0);
        $ranking[] = '%d * (2.0 - 2.0 / (1.0 + MAX(c.comment_count) * %f))';
        $arguments2[] = $weight;
        $arguments2[] = $scale;
        if (!$stats_join) {
          $join2 .= ' LEFT JOIN {node_comment_statistics} c ON c.nid = i.sid';
        }
        $total += $weight;
      }
      if (module_exists('statistics') && variable_get('statistics_count_content_views', 0) &&
          $weight = (int)variable_get('node_rank_views', 5)) {
        // Inverse law that maps the highest view count on the site to 1 and 0 to 0.
        $scale = variable_get('node_cron_views_scale', 0.0);
        $ranking[] = '%d * (2.0 - 2.0 / (1.0 + MAX(nc.totalcount) * %f))';
        $arguments2[] = $weight;
        $arguments2[] = $scale;
        $join2 .= ' LEFT JOIN {node_counter} nc ON nc.nid = i.sid';
        $total += $weight;
      }
      
      // When all search factors are disabled (ie they have a weight of zero), 
      // the default score is based only on keyword relevance and there is no need to 
      // adjust the score of each item. 
      if ($total == 0) {
        $select2 = 'i.relevance AS score';
        $total = 1;
      }
      else {
        $select2 = implode(' + ', $ranking) . ' AS score';
      }
      
      // Do search.
      $find = do_search($keys, 'node', 'INNER JOIN {node} n ON n.nid = i.sid '. $join1, $conditions1 . (empty($where1) ? '' : ' AND '. $where1), $arguments1, $select2, $join2, $arguments2);

      // Load results.
      $results = array();
      foreach ($find as $item) {
        // Build the node body.
        $node = node_load($item->sid);
        $node->build_mode = NODE_BUILD_SEARCH_RESULT;
        $node = node_build_content($node, FALSE, FALSE);
        $node->body = drupal_render($node->content);

        // Fetch comments for snippet.
        $node->body .= module_invoke('comment', 'nodeapi', $node, 'update index');
        // Fetch terms for snippet.
        $node->body .= module_invoke('taxonomy', 'nodeapi', $node, 'update index');

        $extra = node_invoke_nodeapi($node, 'search result');
        $results[] = array(
          'link' => url('node/'. $item->sid, array('absolute' => TRUE)),
          'type' => check_plain(node_get_types('name', $node)),

          //TODO: this is a hack, should override search result template some how, but I'm unsure how to pass additional information through...
          'title' => $node->title .' ('. $node->cc->get_name('short_text') .')',

          'user' => theme('username', $node),
          'date' => $node->changed,
          'node' => $node,
          'extra' => $extra,
          'score' => $item->score / $total,
          'snippet' => search_excerpt($keys, $node->body),
        );
      }
      return $results;
  }
}

/**
 * Search validation function.
 */
function creativecommons_search_validate($form, &$form_state) {
  // Initialise using any existing basic search keywords.
  $keys = $form_state['values']['processed_keys'];
  
  // Insert extra restrictions into the search keywords string.
  $cc_search_filters = array();
  foreach (array('commercial_use', 'derivative_works') as $key) {
    if ($form_state['values'][$key] == 1) {
      $cc_search_filters[] = $key;
    }
  }

  $keys = search_query_insert($keys, 'cc', implode(',', $cc_search_filters));
  form_set_value($form['basic']['inline']['processed_keys'], trim($keys), $form_state);
}

/**
 * Store node type value.
 */
function creativecommons_node_type_submit($form, &$form_state) {
  $node_types = variable_get('creativecommons_node_types', array());
  $type = $form_state['values']['type'];

  $node_types[$type] = !empty($form_state['values']['creativecommons']) ? $type : 0;
  variable_set('creativecommons_node_types', $node_types);
}

/**
 * Append Creative Commons license to an RSS <item> node
 */
function creativecommons_xml($node) {
  if ($node->cc) {
    return array(
      array('key' => 'xmlns:creativeCommons', 'value' => $node->cc->uri)
    );
  }
  return;
}

/**
 * Append rdf content to node. TODO: 2.x RDF/XML is no longer recommended by CC
 */
function creativecommons_view($node, $teaser = FALSE, $page = FALSE) {
  if ($node->cc && variable_get('creativecommons_rdf', TRUE)) {
    $output = "<!-- ". $node->cc->get_rdf() ." -->";
    $node->content['body']['#value'] .= $output;
    if ($teaser) {
      $node->content['teaser']['#value'] .= $output;
    }

    return $node;
  }
}

/**
 * Implementation of hook_link().
 */
function creativecommons_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();

  if ($type == 'node') {
    if ($teaser == 1 && $node->teaser && $node->cc) {
      $links['creativecommons'] = array(
        'title' => t($node->cc->get_image('tiny_icons')),
        'href' => $node->cc->uri,
        'html' => TRUE,
        'attributes' => array('rel' => 'license', 'title' => $node->cc->get_name('full_text')),
      );
    }
  }

  return $links;
}

/**
 * Implementation of hook_block().
 */
function creativecommons_block($op='list', $delta=0, $edit = array()) {
  // listing of blocks, such as on the admin/block page
  switch ($op) {
    case 'list':
      $blocks[0] = array(
        'info' => t('Creative Commons Node License'),
        'weight' => 0,
        'enabled' => 1,   // default make it enabled
        'region' => 'content',
        'theme' => 'garland',
      );

      $blocks[1] = array(
        'info' => t('Creative Commons Site License'),
        'weight' => -10,
        'enabled' => 1,   // default make it enabled
        'region' => 'footer',
        'theme' => 'garland',
      );

      return $blocks;


    case 'view':
      switch ($delta) {
        // Node license
        case 0:
          if (!is_numeric(arg(1))) {
            return;
          }

          $nid = (int)arg(1);
          $node = node_load(array('nid' => $nid));

          if ( $node && arg(0) == 'node' && ( $node->cc && $node->cc->is_available()) && ( (arg(2)=='view') || (arg(2)=='') ) ) {
            // license html
            $block['content'] = $node->cc->get_html();
          }

          return $block;

          // Site license
          case 1:
            if (variable_get('creativecommons_site_license_display', FALSE)) {
              $cc = creativecommons_get_site_license();
              if ($cc->is_available()) {
                $block['content'] =  $cc->output(variable_get('creativecommons_site_license_additional_text', ''));
                $block['subject'] = 'Site License';
              }
              return $block;
            }
      }
  }
}

/**
 * Form for attaching Creative Commons license to a node (not a hook)
 */
function creativecommons_node_form($node, $form_state) {
  // Check user permissions and license availability
  if (!user_access('attach creative commons') || !creativecommons_get_available_license_types()) {
    return array();
  }

  // Add validate and submit functions
  $form['#validate'][] = 'creativecommons_node_form_validate';

  //TODO: review this text (e.g. does "keeping copyright" make sense given CC0?)
  //TODO: l()
  $cc_txt = '<p><a href="http://creativecommons.org/learn/licenses/" target="_blank">Creative Commons licenses</a> help you share your work while keeping your copyright. Other people can copy and distribute your work provided they give you credit -- and only on the conditions you specify here. This form helps you choose those conditions. Visit the Creative Commons website for an <a href="http://creativecommons.org/about/licenses/meet-the-licenses">explanation of the different licenses</a>.

Choose the <a href="http://creativecommons.org/licenses/publicdomain/">Public Domain license</a> or <a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> if you want to offer your work with no conditions.</p>';


  // required metadata
  $required_metadata = variable_get('creativecommons_required_metadata', array());

  // loop thru metadata fields
  $fields = '';
  $metadata_types = creativecommons_get_metadata_types();

  $form['creativecommons'] = array(
    '#type' => 'fieldset',
    '#title' => 'Creative Commons License',
    '#prefix' => '<div class="attachments">',
    '#suffix' => '</div>',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#tree' => TRUE,
  );

  $form['creativecommons'][] = array('#value' => t($cc_txt));
  $form['creativecommons']['select_license_form'] = creativecommons_select_license_form($node, 'cc_license_uri', $form_state['values']['creativecommons']['select_license_form']);


  //TODO: 2.x button 'save user defaults' here? or checkbox maybe (save as defaults...)?

  // Show metadata by default if some stored fields are set
  $show_meta = FALSE;

  // Show metadata by default if some fields are required
  foreach ($required_metadata as $key => $value) {
    if (!empty($value)) {
      $show_meta = TRUE;
      break;
    }
  }

  // Check for non-empty fields if preview mode
  if (!$show_meta && is_array($form_state['values']['creativecommons']['metadata'])) {
    foreach ($form_state['values']['creativecommons']['metadata'] as $key => $value) {
      if ($value) {
        $show_meta = TRUE;
        break;
      }
    }
  }
  // Check for stored non-empty fields if not in preview mode
  else if ($node->cc && $node->cc->has_metadata()) {
    $show_meta = TRUE;
  }

  $form['creativecommons']['metadata'] = array(
    '#type' => 'fieldset',
    '#title' => 'Additional Information',
    '#collapsible' => TRUE,
    // show additional info by default if any metadata fields are (a) required, or (b) non-empty; otherwise, hide.
    '#collapsed' => !$show_meta,
    '#tree' => TRUE,
    );


  // build metadata form fields
  foreach ($metadata_types as $key => $title) {
    $title .= ' of licensed work';
    $selected = is_array($form_state['values']['creativecommons']['metadata']) ? $form_state['values']['creativecommons']['metadata'][$key] : $node->cc->metadata[$key];
    $required = $required_metadata[$key] ? TRUE : FALSE;

    switch ($key) {
      case 'type':
        $form['creativecommons']['metadata'][$key] = array(
          '#type' => 'select',
          '#title' => t($title),
          '#default_value' => $selected,
          '#options' => creativecommons_get_dcmi_types(),
          '#description' => creativecommons_get_metadata_description($key),
          '#extra' => NULL,
          '#multiple' => NULL,
          '#required' => $required,
        );
        break;

      case 'description':
        $form['creativecommons']['metadata'][$key] = array(
          '#type' => 'textarea',
          '#title' => t($title),
          '#default_value' => $selected,
          '#cols' => 60,
          '#rows' => 5,
          '#description' => creativecommons_get_metadata_description($key),
          '#attributes' => NULL,
          '#required' => $required,
        );
        break;

      default:
        $form['creativecommons']['metadata'][$key] = array(
          '#type' => 'textfield',
          '#title' => t($title),
          '#default_value' => $selected,
          '#size' => 50,
          '#maxlength' => 255,
          '#description' => creativecommons_get_metadata_description($key),
          '#attributes' => NULL,
          '#required' => $required,
        );
        break;
    }
  }

  return $form;
}



/**
 * Validate the Creative Commons node form.
 *
 * The case of a non-available license is actually handled well by Drupal already.
 * Drupal says, "an illegal choice has been detected," because only available
 * licenses appear in the form.
 *
 * However, it seems that if a license becomes unavailable after a form is
 * already in edit, or at least the preview stage, then the following check is
 * still needed.
 */
function creativecommons_node_form_validate($form, &$form_state) {

  creativecommons_validate_license_uri('cc_license_uri', $form_state['values']['creativecommons']['select_license_form']['cc_license_uri']);
}

/**
 * Save license/node relationship in database
 */
function creativecommons_save($node, $op) {

  //TODO: shouldn't be using $_POST... what's the drupal way to do this? use submit instead?
  $cc = new creativecommons_license($_POST['creativecommons']['select_license_form']['cc_license_uri'], NULL, $_POST['creativecommons']['metadata']);
  $cc->save($node->nid, $op);

  //TODO: is this line necessary? should it be somewhere else?
  $node->cc = $cc;

  return;
}

/**
  * Delete node/license relationship from database
  */
function creativecommons_delete($node) {
  if ($node->nid) {
    db_query("DELETE FROM {creativecommons} WHERE nid = %d", $node->nid);
  }
  return;
}


/**
 * Returns true if Creative Commons licensing is enabled for this node type;
 * false otherwise
 */
function creativecommons_node_type_is_enabled($type) {
  $node_types = variable_get('creativecommons_node_types', array());

  return !empty($node_types[$type]);
}

/**
 * Find out how many nodes are using a given license type.
 *
 * @param $type -- license type to search for
 * @return the number of nodes licensed under the given type.
 */
function creativecommons_count_by_license_type($type) {
  $result = db_query("SELECT COUNT(*) as count FROM {creativecommons} WHERE license_uri LIKE '". ($type == 'zero' ? 'http://creativecommons.org/publicdomain/zero/%' : 'http://creativecommons.org/licenses/%s/%') ."'", $type);
  if ($result) {
    $row = db_fetch_object($result);
    return $row->count;
  }
}

